// Generated by CoffeeScript 1.8.0

/*
Copyright (c) 2011-2012 Emanuel Rylke

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function() {
  var FAST_PLAY, NUM_ALTAR_PIECES, Shooter, altar, altarInInventar, altarPieces, altarPiecesCount, arrows, bgTiles, brownbunny, bunnies, collectAltarPiece, deathbrownbunny, deathbunnies, deathbunnycount, dog, doggoal, doghasbunny, dogpath, dogpos, dogrun, dogspeed, draw, drawEntity, drawHPBar, drawInventar, drawOnMap, drawPs, flower, flowers, frameInterval, frameTimer, getBgTile, getPatch, getTime, hitp, hunter, hunterImg, initStubs, intersect, knuth, lastZombieWave, lastZombieWaveOffset, mapcanvas, mapctx, meadowbg1, meadowbg2, mousePressed, mp, nigth, patches, pathing, pause, rand255, randpos, rockbg1, rockbg2, runGame, runStubs, shooting, step, trees, walk, zombie, zombieWaveSize, zombies,
    __slice = [].slice;

  initStubs = [];

  runStubs = function(stubs) {
    if (stubs.length > 0) {
      stubs.shift()();
      return setTimeout((function() {
        return runStubs(stubs);
      }), 1);
    } else {
      return setTimeout((function() {
        return runStubs(stubs);
      }), 300);
    }
  };

  FAST_PLAY = window.location.hash === '#fast';

  NUM_ALTAR_PIECES = FAST_PLAY ? 1 : 7;

  arrows = [];

  bunnies = new parray(5000, 500);

  deathbunnies = [];

  flowers = new parray(5000, 500);

  trees = new parray(5000, 500);

  zombies = new parray(5000, 500);

  altarPieces = [];

  altarPiecesCount = 0;

  altarInInventar = false;

  altar = {
    hp: 1000,
    maxhp: 1000
  };

  patches = new stparray(5000);

  this.patches = patches;

  randpos = function() {
    var foo, p;
    while (true) {
      p = [5000 * Math.random(), 5000 * Math.random()];
      foo = false;
      patches.eachin(p, [0, 0], function(patch) {
        if ((distance(patch.p, p)) < patch.r) {
          return foo = true;
        }
      });
      if (foo) {
        return p;
      }
    }
  };

  hunter = null;

  knuth = null;

  dogpos = null;

  doggoal = null;

  doghasbunny = false;

  dogrun = false;

  dogpath = [];

  dogspeed = 0;

  deathbunnycount = 0;

  mp = [0, 0];

  mousePressed = false;

  frameInterval = null;

  getTime = function() {
    return (new Date()).getTime();
  };

  frameTimer = 0;

  nigth = null;

  lastZombieWave = getTime();

  lastZombieWaveOffset = 0;

  zombieWaveSize = 1;

  shooting = false;

  pause = false;

  drawPs = [];

  brownbunny = loadImg('brownbunny.png');

  deathbrownbunny = loadImg('deathbrownbunny.png');

  dog = loadImg('dog.png');

  flower = loadImg('flower.png');

  hunterImg = loadImg('hunter.png');

  zombie = loadImg('zombie.png');

  initStubs.push(function() {
    var flpatch, foo, mindist, obst;
    while (patches.length() < (FAST_PLAY ? 10 : 50)) {
      flpatch = {
        r: 40 + Math.random() * 400,
        n: []
      };
      flpatch.p = [flpatch.r + Math.random() * ((FAST_PLAY ? 1000 : 5000) - flpatch.r * 2), "foo"];
      flpatch.p[1] = 0 - flpatch.r;
      while (true) {
        if (flpatch.p[0] - flpatch.r < 0 || flpatch.p[0] + flpatch.r > 5000 || flpatch.p[1] + flpatch.r > 5000) {
          flpatch.p[1] = Math.min(5000 - flpatch.r, flpatch.p[1]);
          patches.add(flpatch);
          break;
        }
        obst = false;
        foo = false;
        mindist = 50;
        patches.eachin(minus(flpatch.p, [flpatch.r, flpatch.r]), [flpatch.r * 2, flpatch.r * 2 + 50], function(i) {
          mindist = Math.min(mindist, (distance(i.p, flpatch.p)) + 2 - i.r - flpatch.r);
          if ((distance(i.p, flpatch.p)) + 2 < i.r + flpatch.r) {
            if (obst && !foo) {
              patches.add(flpatch);
              return foo = true;
            } else {
              return obst = i;
            }
          }
        });
        if (foo) {
          break;
        }
        if (obst) {
          flpatch.p[1] += 0.1;
          if (obst.p[0] < flpatch.p[0]) {
            flpatch.p[0]++;
          } else {
            flpatch.p[0]--;
          }
        } else {
          flpatch.p[1] += Math.max(1, mindist);
        }
      }
    }
    return null;
  });

  initStubs.push(function() {
    return patches.each(function(patch) {
      return patches.eachinradius(patch.p, patch.r, function(other) {
        if (patch !== other) {
          return patch.n.push(other);
        }
      });
    });
  });

  initStubs.push(function() {
    return patches.each(function(_arg) {
      var i, p, r, tp, _i, _ref, _results;
      r = _arg.r, p = _arg.p;
      _results = [];
      for (i = _i = 0, _ref = Math.pow(Math.random() * 2, 3) | 0; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        tp = plus(p, mult(sincos(Math.random() * tau), r + 10));
        if (!getPatch(tp)) {
          _results.push(trees.add({
            p: tp
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });

  runGame = function() {
    return frameInterval = setInterval((function() {
      var err;
      try {
        return step();
      } catch (_error) {
        err = _error;
        clearInterval(frameInterval);
        throw err;
      }
    }), 40);
  };

  initStubs.push(function() {
    var p, r, _ref;
    _ref = patches.biggestinradius([(FAST_PLAY ? 1000 : 4000), 4000], 2000, function(x) {
      return -1 * (distance([4000, 4000], x.p));
    }), p = _ref.p, r = _ref.r;
    hunter = new Shooter(p);
    dogpos = plus(p, [r / 2, 0]);
    doggoal = hunter.p;
    p = patches.biggestinradius([1000, 4000], 2000, function(x) {
      return x.r / (1500 + (distance(x.p, [1000, 4000])));
    }).p;
    knuth = new Shooter(p);
    return runGame();
  });

  initStubs.push(function() {
    var i;
    return altarPieces = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= NUM_ALTAR_PIECES ? _i < NUM_ALTAR_PIECES : _i > NUM_ALTAR_PIECES; i = 0 <= NUM_ALTAR_PIECES ? ++_i : --_i) {
        _results.push(randpos());
      }
      return _results;
    })();
  });

  rand255 = function() {
    return Math.floor(255 * Math.random());
  };

  mapcanvas = ($('<canvas width="1000" height="1000">'))[0];

  mapctx = mapcanvas.getContext('2d');

  mapctx.scale(0.2, 0.2);

  mapctx.lineWidth = 10;

  mapctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';

  mapctx.fillStyle = 'rgba(0, 0, 0, 0.1)';

  drawOnMap = function(patch) {
    var n, other, p, r, _i, _len;
    if (!patch.drawn) {
      r = patch.r, p = patch.p, n = patch.n;
      for (_i = 0, _len = n.length; _i < _len; _i++) {
        other = n[_i];
        fillRect(mapctx, minus(intersect(patch, other), [10, 10]), [20, 20]);
      }
      mapctx.beginPath();
      arc(mapctx, p, r, 0, tau + 0.001);
      mapctx.stroke();
      return patch.drawn = true;
    }
  };

  initStubs.push(function() {
    return drawOnMap(getPatch(hunter.p));
  });

  rockbg1 = loadImg('rock-bg1.png');

  rockbg2 = loadImg('rock-bg2.png');

  meadowbg1 = loadImg('bg.png');

  meadowbg2 = loadImg('bg2.png');

  bgTiles = {};

  getBgTile = function(p) {
    var cacheTile, can, foo, img, pctx, rctx, rockcan, _i, _j, _len, _len1, _ref, _ref1;
    if (bgTiles[p]) {
      return bgTiles[p];
    } else {
      cacheTile = true;
      can = ($('<canvas width="1000" height="1000">'))[0];
      pctx = can.getContext('2d');
      pctx.fillStyle = '#44aa00';
      translate(pctx, minus([0, 0], p));
      patches.eachin(p, [1000, 1000], function(_arg) {
        var p, r;
        r = _arg.r, p = _arg.p;
        pctx.beginPath();
        arc(pctx, p, r, 0, tau + 0.001);
        return pctx.fill();
      });
      pctx.globalCompositeOperation = 'source-atop';
      _ref = [meadowbg1, meadowbg2];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        img = _ref[_i];
        if (img.complete) {
          foo = [img.width, img.height];
          eachinarearange(floorBy2d(p, foo), plus(p, [1000, 1000]), foo, function(pb) {
            return drawImage(pctx, img, pb);
          });
        } else {
          cacheTile = false;
        }
      }
      rockcan = ($('<canvas width="1000" height="1000">'))[0];
      rctx = rockcan.getContext('2d');
      translate(rctx, minus([0, 0], p));
      _ref1 = [rockbg1, rockbg2];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        img = _ref1[_j];
        if (img.complete) {
          foo = [img.width, img.height];
          eachinarearange(floorBy2d(p, foo), plus(p, [1000, 1000]), foo, function(pb) {
            return drawImage(rctx, img, pb);
          });
        } else {
          cacheTile = false;
        }
      }
      drawImage(rctx, can, p);
      if (cacheTile) {
        bgTiles[p] = rockcan;
      }
      return rockcan;
    }
  };

  drawHPBar = function(ctx, p, hp, maxhp) {
    var size;
    size = Math.pow(maxhp, 0.5) * 4;
    ctx.fillStyle = '#aa2255';
    fillRect(ctx, minus(p, [size / 2, 25]), [size, 3]);
    ctx.fillStyle = '#00dd00';
    return fillRect(ctx, minus(p, [size / 2, 25]), [size * hp / maxhp, 3]);
  };

  drawEntity = function(ctx, img, _arg) {
    var hp, maxhp, p;
    p = _arg.p, hp = _arg.hp, maxhp = _arg.maxhp;
    if (img) {
      drawImage(ctx, img, minus(p, [20, 20]));
    } else {
      fillRect(ctx, minus(p, [20, 20]), [40, 40]);
    }
    if (maxhp) {
      return drawHPBar(ctx, p, hp, maxhp);
    }
  };

  draw = function() {
    var db, m, p, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref;
    ctx.font = '40px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.save();
    translate(ctx, minus([500, 250], hunter.p));
    eachinarearange(floorBy2d(minus(hunter.p, [500, 250]), [1000, 1000]), plus(hunter.p, [500, 250]), [1000, 1000], function(pb) {
      return drawImage(ctx, getBgTile(pb), pb);
    });
    ctx.fillStyle = '#bbaaaa';
    ctx.strokeStyle = '#000000';
    for (_i = 0, _len = altarPieces.length; _i < _len; _i++) {
      p = altarPieces[_i];
      fillRect(ctx, minus(p, [20, 20]), [40, 40]);
    }
    for (_j = 0, _len1 = deathbunnies.length; _j < _len1; _j++) {
      db = deathbunnies[_j];
      drawEntity(ctx, deathbrownbunny, db);
    }
    flowers.eachin(minus(hunter.p, [500, 250]), [1000, 500], function(_arg) {
      var p;
      p = _arg.p;
      return drawImage(ctx, flower, minus(p, [10, 10]));
    });
    bunnies.eachin(minus(hunter.p, [500, 250]), [1000, 500], function(_arg) {
      var p;
      p = _arg.p;
      return drawImage(ctx, brownbunny, minus(p, [20, 20]));
    });
    drawImage(ctx, dog, minus(dogpos, [20, 20]));
    if (doghasbunny) {
      drawImage(ctx, deathbrownbunny, minus(dogpos, [10, 10]));
    }
    fillRect(ctx, minus(knuth.p, [20, 20]), [40, 40]);
    if (altar.p) {
      drawEntity(ctx, null, altar);
    }
    drawImage(ctx, hunterImg, minus(hunter.p, [20, 20]));
    ctx.fillStyle = '#ffffff';
    ctx.fillText("Knuth", knuth.p[0] - 40, knuth.p[1] - 40);
    ctx.strokeText("Knuth", knuth.p[0] - 40, knuth.p[1] - 40);
    zombies.eachin(minus(hunter.p, [500, 250]), [1000, 500], function(z) {
      return drawEntity(ctx, zombie, z);
    });
    for (_k = 0, _len2 = arrows.length; _k < _len2; _k++) {
      _ref = arrows[_k], p = _ref.p, m = _ref.m;
      ctx.beginPath();
      moveTo(ctx, p);
      lineTo(ctx, plus(p, m));
      ctx.closePath();
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(32, 110, 10, 0.8)';
    trees.eachin(minus(hunter.p, [500, 250]), [1000, 500], function(_arg) {
      var p;
      p = _arg.p;
      ctx.beginPath();
      arc(ctx, p, 60, 0, tau + 0.001);
      return ctx.fill();
    });
    for (_l = 0, _len3 = drawPs.length; _l < _len3; _l++) {
      p = drawPs[_l];
      fillRect(ctx, p, [10, 10]);
    }
    drawPs = [];
    ctx.restore();
    ctx.save();
    translate(ctx, minus([500, 250], mult(hunter.p, 0.2)));
    drawImage(ctx, mapcanvas, [0, 0]);
    ctx.scale(0.2, 0.2);
    ctx.fillStyle = 'rgba(255,255,255, 0.4)';
    for (_m = 0, _len4 = altarPieces.length; _m < _len4; _m++) {
      p = altarPieces[_m];
      if ((getPatch(p)).drawn) {
        fillRect(ctx, minus(p, [10, 10]), [20, 20]);
      }
    }
    ctx.restore();
    ctx.fillStyle = "rgba(0, 0, 0, " + nigth + ")";
    return fillRect(ctx, [0, 0], [1000, 500]);
  };

  hitp = function(bunny) {
    var a, _i, _len;
    for (_i = 0, _len = arrows.length; _i < _len; _i++) {
      a = arrows[_i];
      if (contains(a.p, minus(bunny.p, [20, 20]), plus(bunny.p, [20, 20]))) {
        a.p = [-100, -100];
        return true;
      }
    }
    return false;
  };

  intersect = function(patch1, patch2) {
    return plus(patch1.p, mult(direction(patch1.p, patch2.p), patch1.r));
  };

  getPatch = function(p) {
    var res;
    res = false;
    patches.eachin(p, [0, 0], function(patch) {
      if ((distance(p, patch.p)) < patch.r) {
        return res = patch;
      }
    });
    return res;
  };

  pathing = function(p1, p2) {
    var bar, bla, closed, j, n, newpath, open, p1patch, p2patch, pth, _i, _j, _len, _ref, _ref1;
    p1patch = getPatch(p1);
    p2patch = getPatch(p2);
    if (!p2patch) {
      return [p1];
    } else if (p2patch === p1patch || !p1patch) {
      return [p2];
    } else {
      open = [
        {
          heurD: distance(p1, p2),
          measD: 0,
          p: [p2patch]
        }
      ];
      closed = [];
      while (true) {
        open.sort(function(a, b) {
          return (a.heurD + a.measD) - (b.heurD + b.measD);
        });
        if (open.length === 0) {
          return [p1];
        }
        pth = open.shift();
        closed.push(pth.p[0]);
        _ref = pth.p[0].n;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (n === p1patch) {
            return __slice.call(intlvmap([n].concat(__slice.call(pth.p)), intersect)).concat([p2]);
          }
          bar = one(closed, function(x) {
            return x === n;
          });
          if (!bar) {
            newpath = {
              heurD: distance(p1, intersect(pth.p[0], n)),
              measD: pth.measD + (distance(intersect(pth.p[0], n), (pth.p.length > 1 ? intersect(pth.p[0], pth.p[1]) : p2))),
              p: [n].concat(__slice.call(pth.p))
            };
            bla = true;
            for (j = _j = 0, _ref1 = open.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              if (open[j].p[0] === n) {
                if (open[j].heurD + open[j].measD > newpath.heurD + newpath.measD) {
                  open[j] = newpath;
                }
                bla = false;
                break;
              }
            }
            if (bla) {
              open.push(newpath);
            }
          }
        }
      }
    }
    throw "the controlflow should never go here";
  };

  walk = function(start, goal, speed) {
    var path;
    path = pathing(start, goal);
    return plus(start, mult(direction(start, path[0]), speed));
  };

  Shooter = (function() {
    function Shooter(p) {
      this.p = p;
      this.target = null;
      this.lastShoot = 0;
    }

    Shooter.prototype.behave = function() {
      if (this.target && frameTimer - 4 > this.lastShoot) {
        arrows.push({
          h: 30,
          p: this.p,
          m: mult(direction(this.p, this.target), 20)
        });
        return this.lastShoot = frameTimer;
      }
    };

    return Shooter;

  })();

  drawInventar = function() {
    var foo, res;
    res = '';
    if (deathbunnycount > 0) {
      res += '<br>Bunnies: ' + deathbunnycount;
    }
    if (altarPiecesCount > 0) {
      res += '<br>Altar Pieces: ' + altarPiecesCount;
      if (altarPiecesCount === NUM_ALTAR_PIECES) {
        res += '<br><a onclick="javascript:repairAltar()" href="javascript:void(0)">repair altar</a>';
      }
    }
    if (altarInInventar) {
      res += '<br>Altar: 1<br><a onclick="javascript:placeAltar()" href="javascript:void(0)">place altar</a>';
    }
    if (res) {
      res = 'Inventar:' + res;
    }
    foo = $('#inventar')[0];
    if (foo.innerHTML !== res) {
      return foo.innerHTML = res;
    }
  };

  collectAltarPiece = function() {
    return altarPiecesCount++;
  };

  this.repairAltar = function() {
    altarPiecesCount = 0;
    altarInInventar = true;
    return false;
  };

  this.placeAltar = function() {
    altar.p = hunter.p;
    altarInInventar = false;
    return false;
  };

  step = function() {
    var a, bar, db, db2, dist, foo, goal, hp, i, newarrows, newbunnies, newdeathbunnies, newflowers, newzombies, patch, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref;
    _ref = (getPatch(hunter.p)).n;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      patch = _ref[_i];
      drawOnMap(patch);
    }
    frameTimer++;
    nigth = ((Math.sin(frameTimer / (25 * 60))) + 1) / 4;
    if (mousePressed) {
      hunter.goal = plus(mp, minus(hunter.p, [500, 250]));
    }
    if (hunter.goal) {
      hunter.p = walk(hunter.p, hunter.goal, 6);
      if ((distance(hunter.p, hunter.goal)) < 6) {
        hunter.goal = null;
      }
    }
    if (bunnies.length() < 5) {
      bunnies.add({
        p: randpos(),
        alarmed: false,
        life: 100
      });
    }
    if (ptrue(0.5)) {
      flowers.add({
        p: randpos(),
        death: false
      });
    }
    if (getTime() - 60 * 1000 > lastZombieWave) {
      for (i = _j = 0; 0 <= zombieWaveSize ? _j < zombieWaveSize : _j > zombieWaveSize; i = 0 <= zombieWaveSize ? ++_j : --_j) {
        hp = 5 + Math.random() * 10 | 0;
        zombies.add({
          p: randpos(),
          sleep: 100,
          hp: hp,
          maxhp: hp,
          subgoal: [0, 0],
          subgoalcounter: 0
        });
      }
      zombieWaveSize++;
      lastZombieWave = getTime();
    }
    if (hunter.target) {
      hunter.target = plus(mp, minus(hunter.p, [500, 250]));
    }
    hunter.behave();
    knuth.target = null;
    foo = 1;
    zombies.eachinradius(knuth.p, 400, function(zombie) {
      if (Math.random() < 1 / foo) {
        knuth.target = zombie.p;
      }
      return foo++;
    });
    knuth.behave();
    altarPieces = altarPieces.filter(function(a) {
      if (distance(a, hunter.p) < 40) {
        collectAltarPiece();
        return false;
      } else {
        return true;
      }
    });
    newarrows = [];
    for (_k = 0, _len1 = arrows.length; _k < _len1; _k++) {
      a = arrows[_k];
      goal = plus(a.p, a.m);
      bar = false;
      patches.eachin(goal, [0, 0], function(patch) {
        if ((distance(patch.p, goal)) < patch.r - 1) {
          return bar = true;
        }
      });
      if (bar) {
        a.p = goal;
      }
      foo = true;
      zombies.eachinradius(a.p, 20, function(zombie) {
        if (foo) {
          zombie.hp--;
          return foo = false;
        }
      });
      if (a.h > 1 && foo && bar) {
        a.h -= 1;
        newarrows.push(a);
      }
    }
    arrows = newarrows;
    newbunnies = new parray(5000, 500);
    bunnies.each(function(bunny) {
      var bunnygoal, bunnyspeed, d, dist, f, hd, inter, newd, other, _l, _len2, _ref1;
      bunnygoal = bunny.p;
      bunnyspeed = 0;
      if (hitp(bunny)) {
        deathbunnies.push(bunny);
        return;
      }
      if (bunny.life < 1) {
        return;
      }
      bunny.life--;
      dist = distance(hunter.p, bunny.p);
      if (dist < 150) {
        bunnies.eachinradius(bunny.p, 150, function(otherbunny) {
          return otherbunny.alarmed = true;
        });
      }
      if (bunny.alarmed) {
        bunny.alarmed = dist < 600;
        bunnyspeed = 10;
        d = 0;
        patch = getPatch(bunny.p);
        _ref1 = patch.n;
        for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
          other = _ref1[_l];
          inter = intersect(patch, other);
          newd = distance(inter, bunny.p);
          hd = distance(inter, hunter.p);
          if (newd < hd && d < hd) {
            d = hd;
            bunnygoal = other.p;
          }
        }
      } else {
        if (bunny.life > 1000) {
          bunny.life -= 200;
          bunny.life /= 2;
          newbunnies.add({
            p: plus(bunny.p, [0, 0]),
            alarmed: false,
            life: bunny.life
          });
        }
        f = {
          p: [99999, 99999]
        };
        flowers.eachin(minus(bunny.p, [500, 500]), [1000, 1000], function(f2) {
          if ((distance(f.p, bunny.p)) > (distance(f2.p, bunny.p))) {
            if ((distance(f2.p, bunny.p)) > (distance(f2.p, hunter.p))) {
              other = true;
            } else {
              other = false;
              bunnies.eachin(minus(bunny.p, [50, 50]), [100, 100], function(otherbunny) {
                if ((bunny !== otherbunny) && (distance(f2.p, bunny.p)) > (distance(f2.p, otherbunny.p))) {
                  return other = true;
                }
              });
            }
            if (!other) {
              return f = f2;
            }
          }
        });
        if (f.p[0] !== 99999) {
          bunnyspeed = 8;
          bunnygoal = f.p;
          if ((distance(f.p, bunny.p)) < 20) {
            bunny.life += 50;
            f.death = true;
          }
        }
      }
      bunny.p = walk(bunny.p, bunnygoal, bunnyspeed);
      return newbunnies.add(bunny);
    });
    bunnies = newbunnies;
    doggoal = dogpos;
    if (doghasbunny) {
      if ((distance(dogpos, hunter.p)) < 50) {
        deathbunnycount++;
        doghasbunny = false;
      } else {
        dogspeed = 10;
        doggoal = hunter.p;
      }
    } else {
      db = {
        p: [99999, 99999]
      };
      for (_l = 0, _len2 = deathbunnies.length; _l < _len2; _l++) {
        db2 = deathbunnies[_l];
        dist = distance(db2.p, dogpos);
        if (dist < 500 && dist < (distance(dogpos, db.p))) {
          db = db2;
        }
      }
      if (db.p[0] !== 99999) {
        dogspeed = 10;
        doggoal = db.p;
      } else if (dogrun) {
        if ((distance(dogpos, hunter.p)) > 90) {
          dogspeed = 7;
          doggoal = hunter.p;
        } else {
          dogrun = false;
        }
      } else if ((distance(dogpos, hunter.p)) > 250) {
        dogrun = true;
      }
    }
    dogpos = walk(dogpos, doggoal, dogspeed);
    newzombies = new parray(5000, 500);
    zombies.each(function(zombie) {
      if ((!FAST_PLAY) && nigth < 0.25) {
        zombie.hp -= 0.1;
      }
      if (zombie.sleep < 1) {
        if (zombie.subgoalcounter < 1 || (distance(zombie.subgoal, zombie.p)) < zombie.hp / 2 || (distance(zombie.p, hunter.p)) < 400) {
          zombie.subgoal = (pathing(zombie.p, altar.p || hunter.p))[0];
          zombie.subgoalcounter = 200;
        }
        zombie.subgoalcounter--;
        zombie.p = plus(zombie.p, mult(direction(zombie.p, zombie.subgoal), zombie.hp / 2));
        zombies.eachinradius(zombie.p, 40, function(other) {
          var _ref1;
          if (other !== zombie) {
            if (other.sleep < 5) {
              other.sleep += 10;
            }
            if ((0 < (_ref1 = zombie.maxhp - zombie.hp) && _ref1 < other.maxhp - other.hp)) {
              other.hp--;
              return zombie.hp++;
            }
          }
        });
        if ((distance(hunter.p, zombie.p)) < 10) {
          pr("You die! but you got " + deathbunnycount + " bunnies!");
          clearInterval(frameInterval);
        }
      } else {
        zombie.sleep--;
      }
      if (zombie.hp > 0) {
        return newzombies.add(zombie);
      }
    });
    zombies = newzombies;
    if (altar.p) {
      altar.hp = Math.min(altar.maxhp, altar.hp + 0.005);
      zombies.eachinradius(altar.p, 40, function(z) {
        altar.hp -= 0.01;
        if (altar.hp <= 0) {
          return altar.p = void 0;
        }
      });
    }
    newdeathbunnies = [];
    for (_m = 0, _len3 = deathbunnies.length; _m < _len3; _m++) {
      db = deathbunnies[_m];
      if ((distance(db.p, hunter.p)) < 50) {
        deathbunnycount++;
      } else if ((!doghasbunny) && (distance(db.p, dogpos)) < 50) {
        doghasbunny = true;
      } else {
        newdeathbunnies.push(db);
      }
    }
    deathbunnies = newdeathbunnies;
    newflowers = new parray(5000, 500);
    flowers.each(function(f) {
      if (!f.death) {
        return newflowers.add(f);
      }
    });
    flowers = newflowers;
    draw();
    return drawInventar();
  };

  ($(document)).keydown(function(evt) {
    var cnvs;
    switch (String.fromCharCode(evt.which)) {
      case ' ':
        if (hunter.target) {
          hunter.target = null;
        } else {
          cnvs = $('canvas');
          mp = minus([evt.pageX, evt.pageY], [cnvs.offset().left, cnvs.offset().top]);
          hunter.target = plus(mp, minus(hunter.p, [500, 250]));
        }
        break;
      case 'P':
        if (pause) {
          pause = false;
          lastZombieWave = getTime() - lastZombieWaveOffset;
          runGame();
        } else {
          pause = true;
          clearInterval(frameInterval);
          lastZombieWaveOffset = getTime() - lastZombieWave;
          ctx.fillStyle = 'rgba(128,128,128,0.3)';
          fillRect(ctx, [0, 0], [1000, 500]);
          ctx.fillStyle = '#000000';
          ctx.fillText("Press P to continue playing.", 200, 250);
        }
        break;
      default:
        return;
    }
    return evt.preventDefault();
  });

  $(function() {
    var cnvs;
    runStubs(initStubs);
    cnvs = $('canvas');
    ($('canvas')).mousemove(function(evt) {
      mp = minus([evt.pageX, evt.pageY], [cnvs.offset().left, cnvs.offset().top]);
      return evt.preventDefault();
    });
    ($('canvas')).mousedown(function(evt) {
      mousePressed = true;
      mp = minus([evt.pageX, evt.pageY], [cnvs.offset().left, cnvs.offset().top]);
      hunter.goal = plus(mp, minus(hunter.p, [500, 250]));
      return true;
    });
    return ($('canvas')).mouseup(function() {
      mousePressed = false;
      return true;
    });
  });

}).call(this);
